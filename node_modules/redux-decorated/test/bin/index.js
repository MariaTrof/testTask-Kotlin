'use strict';
const chai_1 = require('chai');
const mock_functions_1 = require('mock-functions');
const redux_decorated_1 = require('redux-decorated');
describe('createActions', () => {
    it('should return an instance with type set on every action', () => {
        const actions = redux_decorated_1.createActions({
            create: {},
            save: {
                meta: {
                    toString: true,
                }
            },
        });
        chai_1.expect(actions.create).to.deep.equal({ type: 'create' });
        chai_1.expect(actions.save).to.deep.equal({ type: 'save', meta: { toString: true } });
    });
    it('should keep properties set on the actions', () => {
        const actions = redux_decorated_1.createActions({
            create: { type: 'new' },
        });
        chai_1.expect(actions.create).to.deep.equal({ type: 'new' });
    });
    it('should support setting a prefx', () => {
        const actions = redux_decorated_1.createActions({
            create: {},
        }, { prefix: 'test' });
        chai_1.expect(actions.create).to.deep.equal({ type: 'testcreate' });
    });
});
describe('createReducer', () => {
    it('should return a chainable builder', () => {
        const reducer = redux_decorated_1.createReducer([]);
        chai_1.expect(reducer.when({ type: 'type' }, (s, a) => s)).to.equal(reducer);
    });
    it('should call the correct handler when an action is fired', () => {
        const handler1 = mock_functions_1.createMockFunction().returns('1');
        const handler2 = mock_functions_1.createMockFunction().returns('2');
        const reducer = redux_decorated_1.createReducer([])
            .when({ type: '1' }, handler1)
            .when({ type: '2' }, handler2);
        chai_1.expect(reducer(undefined, { type: '1' })).to.equal('1');
        chai_1.expect(handler1.calls.length).to.equal(1);
        chai_1.expect(handler2.calls.length).to.equal(0);
    });
    it('should return the initial state if no action matches', () => {
        const handler1 = mock_functions_1.createMockFunction().returns('1');
        const handler2 = mock_functions_1.createMockFunction().returns('2');
        const reducer = redux_decorated_1.createReducer('0')
            .when({ type: '1' }, handler1)
            .when({ type: '2' }, handler2);
        chai_1.expect(reducer(undefined, { type: '3' })).to.equal('0');
        chai_1.expect(handler1.calls.length).to.equal(0);
        chai_1.expect(handler2.calls.length).to.equal(0);
    });
    it('should return the current state if no action matches', () => {
        const handler1 = mock_functions_1.createMockFunction().returns('1');
        const handler2 = mock_functions_1.createMockFunction().returns('2');
        const reducer = redux_decorated_1.createReducer('0')
            .when({ type: '1' }, handler1)
            .when({ type: '2' }, handler2);
        chai_1.expect(reducer('3', { type: '0' })).to.equal('3');
        chai_1.expect(handler1.calls.length).to.equal(0);
        chai_1.expect(handler2.calls.length).to.equal(0);
    });
    it('should pass the payload and state to the handler', () => {
        const handler = mock_functions_1.createMockFunction();
        const reducer = redux_decorated_1.createReducer('0')
            .when({ type: '1' }, handler);
        reducer('2', { type: '1', payload: '3' });
        chai_1.expect(handler.calls.length).to.equal(1);
        chai_1.expect(handler.calls[0].args).to.deep.equal(['2', '3']);
    });
    describe('handlers returning a function to modify state', () => {
        it('should pass the payload and state to the handler', () => {
            const stateMapper = mock_functions_1.createMockFunction();
            const handler = mock_functions_1.createMockFunction().returns(stateMapper);
            const reducer = redux_decorated_1.createReducer('0')
                .when({ type: '1' }, (_, payload) => handler(payload));
            reducer('2', { type: '1', payload: '3' });
            chai_1.expect(handler.calls.length).to.equal(1);
            chai_1.expect(stateMapper.calls.length).to.equal(1);
            chai_1.expect(handler.calls[0].args).to.deep.equal(['3']);
            chai_1.expect(stateMapper.calls[0].args).to.deep.equal(['2']);
        });
        it('should return the value returned by the handler', () => {
            const reducer = redux_decorated_1.createReducer('0')
                .when({ type: '1' }, _ => _ => '3');
            chai_1.expect(reducer('2', { type: '1' })).to.equal('3');
        });
    });
});
describe('removeIn', () => {
    it('should be able to remove a deep preoperty', () => {
        const old = { deeply: { nested: { property: true } } };
        const result = redux_decorated_1.removeIn(['deeply', 'nested', 'property'], old);
        chai_1.expect(old.deeply.nested.property).to.be.true;
        chai_1.expect(result.deeply.nested.property).to.be.undefined;
    });
});
