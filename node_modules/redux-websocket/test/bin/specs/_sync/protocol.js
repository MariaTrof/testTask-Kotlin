'use strict';
const chai_1 = require('chai');
const constants_1 = require('redux-websocket/lib/_sync/constants');
const protocol_1 = require('redux-websocket/lib/_sync/protocol');
const mock_functions_1 = require('mock-functions');
describe('sync/protocol', () => {
    describe('checkVersionFunction', () => {
    });
    describe('createProtocol', () => {
        describe('onmessage', () => {
            it('should call the checkVersionFunction when checkVersion are received', () => {
                const checkVersionMock = mock_functions_1.createMockFunction();
                const getStateMock = mock_functions_1.createMockFunction();
                const protocol = protocol_1.createServerProtocol(checkVersionMock, getStateMock);
                const versions = {};
                const respondMock = mock_functions_1.createMockFunction();
                protocol.onmessage({ type: constants_1.checkVersion, payload: { versions: versions } }, respondMock);
                chai_1.expect(checkVersionMock.calls.length).to.equal(1);
                chai_1.expect(checkVersionMock.calls[0].args.length).to.equal(3);
                chai_1.expect(checkVersionMock.calls[0].args[0]).to.equal(getStateMock);
                chai_1.expect(checkVersionMock.calls[0].args[1]).to.equal(versions);
                chai_1.expect(checkVersionMock.calls[0].args[2]).to.equal(respondMock);
            });
            it('should dispatch actions defined by this module', () => {
                const dispatchMock = mock_functions_1.createMockFunction();
                const protocol = protocol_1.createClientProtocol(mock_functions_1.createMockFunction(), dispatchMock);
                for (const type of Object.keys(constants_1.actions)) {
                    protocol.onmessage({ type: constants_1.dispatchAction, payload: { type: type } });
                }
                chai_1.expect(dispatchMock.calls.length).to.equal(Object.keys(constants_1.actions).length);
            });
            it('should not dispatch actions not defined by this module', () => {
                const dispatchMock = mock_functions_1.createMockFunction();
                const protocol = protocol_1.createClientProtocol(mock_functions_1.createMockFunction(), dispatchMock);
                protocol.onmessage({ type: constants_1.dispatchAction, payload: { type: 'action' } });
                chai_1.expect(dispatchMock.calls.length).to.equal(0);
            });
        });
        describe('maybeCheckVersion', () => {
            it('should call send only after both onopen and setRehydrationCompleted have been called', () => {
                const protocol1 = protocol_1.createClientProtocol(mock_functions_1.createMockFunction().returns({}), null);
                const protocol2 = protocol_1.createClientProtocol(mock_functions_1.createMockFunction().returns({}), null);
                protocol1.send = mock_functions_1.createMockFunction();
                protocol2.send = mock_functions_1.createMockFunction();
                protocol1.maybeCheckVersion();
                protocol2.maybeCheckVersion();
                chai_1.expect(protocol1.send.calls.length).to.equal(0);
                chai_1.expect(protocol2.send.calls.length).to.equal(0);
                protocol1.onopen();
                protocol2.setRehydrationCompleted();
                protocol1.maybeCheckVersion();
                protocol2.maybeCheckVersion();
                chai_1.expect(protocol1.send.calls.length).to.equal(0);
                chai_1.expect(protocol2.send.calls.length).to.equal(0);
                protocol1.setRehydrationCompleted();
                protocol2.onopen();
                protocol1.maybeCheckVersion();
                chai_1.expect(protocol1.send.calls.length).to.equal(1);
                chai_1.expect(protocol2.send.calls.length).to.equal(1);
            });
            it('should send the current versions', () => {
                const protocol = protocol_1.createClientProtocol(mock_functions_1.createMockFunction().returns({ key: { prop: 1 }, versions: { key: 1 } }), null);
                protocol.send = mock_functions_1.createMockFunction();
                protocol.setRehydrationCompleted();
                protocol.onopen();
                chai_1.expect(protocol.send.calls.length).to.equal(1);
                chai_1.expect(protocol.send.calls[0].args).to.deep.equal([{
                        type: constants_1.checkVersion,
                        payload: { versions: { key: 1 } },
                    }]);
            });
        });
    });
});
