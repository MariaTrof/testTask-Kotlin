'use strict';
const chai_1 = require('chai');
const constants_1 = require('redux-websocket/lib/_sync/constants');
const middlewares_1 = require('redux-websocket/lib/_sync/middlewares');
const mock_functions_1 = require('mock-functions');
describe('sync/middlewares', () => {
    describe('diffingMiddleware', () => {
        it('should pass through dispatched actions', () => {
            const dispatchMock = mock_functions_1.createMockFunction();
            const store = { getState: mock_functions_1.createMockFunction() };
            const dispatch = middlewares_1.diffingMiddleware({ keys: [] }, null)(store)(dispatchMock);
            dispatch({ type: 'dispatched' });
            chai_1.expect(dispatchMock.calls.length).to.equal(1);
            chai_1.expect(dispatchMock.calls[0].args).to.deep.equal([{ type: 'dispatched' }]);
        });
        it('should not send when there are no changes', () => {
            const dispatchMock = mock_functions_1.createMockFunction();
            const store = { getState: mock_functions_1.createMockFunction().returns({}) };
            const protocol = { send: mock_functions_1.createMockFunction() };
            const dispatch = middlewares_1.diffingMiddleware({ keys: [] }, protocol)(store)(dispatchMock);
            dispatch({ type: 'dispatched' });
            chai_1.expect(protocol.send.calls.length).to.equal(0);
        });
        it('should send changes in keys to check', () => {
            const dispatchMock = mock_functions_1.createMockFunction();
            const store = {
                getState: mock_functions_1.createMockFunction()
                    .returns(0, {})
                    .returns(1, { prop: 'new', versions: { prop: 2 } }),
            };
            const protocol = { sendToStoreClients: mock_functions_1.createMockFunction() };
            const dispatch = middlewares_1.diffingMiddleware({ keys: ['prop'] }, protocol)(store)(dispatchMock);
            dispatch({ type: 'dispatched' });
            chai_1.expect(protocol.sendToStoreClients.calls.length).to.equal(1);
            chai_1.expect(protocol.sendToStoreClients.calls[0].args).to.deep.equal([{
                    type: constants_1.dispatchAction,
                    payload: {
                        type: constants_1.actions.updateSyncedState.type,
                        meta: {
                            toClient: true,
                        },
                        payload: [{
                                changes: [{
                                        path: [],
                                        value: 'new',
                                    }],
                                key: 'prop',
                                version: 2,
                            }],
                    },
                }]);
        });
        it('should not send changes in keys to ignore', () => {
            const dispatchMock = mock_functions_1.createMockFunction();
            const store = { getState: mock_functions_1.createMockFunction().returns(0, {}).returns(1, { prop: 'new' }) };
            const protocol = { send: mock_functions_1.createMockFunction() };
            const dispatch = middlewares_1.diffingMiddleware({ keys: [] }, protocol)(store)(dispatchMock);
            dispatch({ type: 'dispatched' });
            chai_1.expect(protocol.send.calls.length).to.equal(0);
        });
    });
    describe('trackRehydrationMiddleware', () => {
        it('should pass through dispatched actions', () => {
            const dispatchMock = mock_functions_1.createMockFunction();
            const protocol = {
                setRehydrationCompleted: mock_functions_1.createMockFunction(),
                maybeCheckVersion: mock_functions_1.createMockFunction(),
            };
            const store = { getState: mock_functions_1.createMockFunction() };
            const dispatch = middlewares_1.trackRehydrationMiddleware({}, protocol)(store)(dispatchMock);
            dispatch({ type: 'dispatched' });
            chai_1.expect(dispatchMock.calls.length).to.equal(1);
            chai_1.expect(dispatchMock.calls[0].args).to.deep.equal([{ type: 'dispatched' }]);
        });
        it('should directly call maybeCheckVersion if waitForAction is null', () => {
            const protocol = {
                setRehydrationCompleted: mock_functions_1.createMockFunction(),
                maybeCheckVersion: mock_functions_1.createMockFunction(),
            };
            middlewares_1.trackRehydrationMiddleware({ waitForAction: null }, protocol)(null)(null);
            chai_1.expect(protocol.setRehydrationCompleted.calls.length).to.equal(1);
            chai_1.expect(protocol.maybeCheckVersion.calls.length).to.equal(1);
        });
        it('should not call maybeCheckVersion for other actions than waitForAction', () => {
            const dispatchMock = mock_functions_1.createMockFunction();
            const protocol = {
                setRehydrationCompleted: mock_functions_1.createMockFunction(),
                maybeCheckVersion: mock_functions_1.createMockFunction(),
            };
            const dispatch = middlewares_1.trackRehydrationMiddleware({ waitForAction: 'action' }, protocol)(null)(dispatchMock);
            dispatch({ type: 'other' });
            chai_1.expect(protocol.setRehydrationCompleted.calls.length).to.equal(0);
            chai_1.expect(protocol.maybeCheckVersion.calls.length).to.equal(0);
        });
        it('should call maybeCheckVersion for waitForAction', () => {
            const dispatchMock = mock_functions_1.createMockFunction();
            const protocol = {
                setRehydrationCompleted: mock_functions_1.createMockFunction(),
                maybeCheckVersion: mock_functions_1.createMockFunction(),
            };
            const dispatch = middlewares_1.trackRehydrationMiddleware({ waitForAction: 'action' }, protocol)(null)(dispatchMock);
            dispatch({ type: 'action' });
            chai_1.expect(protocol.setRehydrationCompleted.calls.length).to.equal(1);
            chai_1.expect(protocol.maybeCheckVersion.calls.length).to.equal(1);
        });
    });
});
