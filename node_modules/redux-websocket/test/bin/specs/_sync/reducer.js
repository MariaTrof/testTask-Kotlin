'use strict';
const chai_1 = require('chai');
const constants_1 = require('redux-websocket/lib/_sync/constants');
const reducer_1 = require('redux-websocket/lib/_sync/reducer');
const mock_functions_1 = require('mock-functions');
describe('sync/syncReducer', () => {
    describe('action: initialSyncedState', () => {
        it('should apply state and versions from the server', () => {
            const reducer = reducer_1.syncReducer({
                keys: ['old', 'current', 'new', 'skip'],
                skipVersion: ['skip'],
            }, null, null);
            const result = reducer({
                old: 1,
                current: 1,
                versions: { old: 1, current: 2 },
            }, {
                type: constants_1.actions.initialSyncedState.type,
                payload: {
                    state: {
                        old: 2,
                        new: 1,
                    },
                    versions: {
                        old: 2,
                        new: 1,
                    },
                },
            });
            chai_1.expect(result).to.deep.equal({
                old: 2,
                current: 1,
                new: 1,
                versions: { old: 2, current: 2, new: 1 },
            });
        });
    });
    describe('action: updateSyncedState', () => {
        it('should apply state and versions from the server', () => {
            const reducer = reducer_1.syncReducer({ keys: ['old', 'current'] }, null, null);
            const result = reducer({
                old: 1,
                current: 1,
                ignored: 1,
                versions: { old: 1, current: 2 },
            }, {
                type: constants_1.actions.updateSyncedState.type,
                payload: [
                    {
                        key: 'old',
                        version: 2,
                        changes: [{ path: [], value: 2 }],
                    },
                    {
                        key: 'ignored',
                        version: 1,
                        changes: [{ path: [], value: 2 }],
                    },
                ],
            });
            chai_1.expect(result).to.deep.equal({
                old: 2,
                current: 1,
                ignored: 1,
                versions: { old: 2, current: 2 },
            });
        });
        it('should call maybeCheckVersion if versions differ', () => {
            const protocol = { maybeCheckVersion: mock_functions_1.createMockFunction() };
            const reducer = reducer_1.syncReducer({ keys: ['old'] }, protocol, null);
            const result = reducer({ old: 1, versions: { old: 1 } }, {
                type: constants_1.actions.updateSyncedState.type,
                payload: [{
                        key: 'old',
                        version: 3,
                        changes: [{ path: [], value: 2 }],
                    }],
            });
            chai_1.expect(protocol.maybeCheckVersion.calls.length).to.equal(1);
            chai_1.expect(result).to.deep.equal({
                old: 1,
                versions: { old: 1 },
            });
        });
    });
    describe('other actions', () => {
        it('should pass through an undefined state to the reducer', () => {
            const reducerMock = mock_functions_1.trackCalls(() => ({}));
            const reducer = reducer_1.syncReducer({ keys: [] }, null, reducerMock);
            const result = reducer(undefined, {});
            chai_1.expect(reducerMock.calls.length).to.equal(1);
            chai_1.expect(reducerMock.calls[0].args[0]).to.equal(undefined);
            chai_1.expect(result).to.deep.equal({});
        });
        it('should pass through to the passed reducer', () => {
            const reducerMock = mock_functions_1.trackCalls(() => ({ prop: 2 }));
            const reducer = reducer_1.syncReducer({ keys: [] }, null, reducerMock);
            const result = reducer({ prop: 1 }, { type: 'other' });
            chai_1.expect(reducerMock.calls.length).to.equal(1);
            chai_1.expect(reducerMock.calls[0].args).to.deep.equal([{ prop: 1 }, { type: 'other' }]);
            chai_1.expect(result).to.deep.equal({ prop: 2 });
        });
        it('should bump the version of changed key', () => {
            const reducerMock = mock_functions_1.trackCalls(state => ({
                ignore: 2, skip: 2, bump: 2, new: 1, keep: state.keep,
            }));
            const reducer = reducer_1.syncReducer({ keys: ['skip', 'keep', 'bump', 'new'], skipVersion: ['skip'] }, null, reducerMock);
            const result = reducer({ ignore: 1, skip: 1, keep: 1, bump: 1, versions: { bump: 1 } }, { type: 'other' });
            chai_1.expect(result).to.deep.equal({
                ignore: 2, skip: 2, bump: 2, keep: 1, new: 1, versions: { bump: 2, new: 1 },
            });
        });
    });
});
