"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WebSocketClient = function () {
    function WebSocketClient(_ref) {
        var url = _ref.url;
        var onOpen = _ref.onOpen;

        _classCallCheck(this, WebSocketClient);

        this.isServer = false;
        this.protocols = {};
        this.open = false;
        this.messagesToSend = [];
        this.connect(url, onOpen);
    }

    _createClass(WebSocketClient, [{
        key: "registerProtocol",
        value: function registerProtocol(name, protocol) {
            var _this = this;

            protocol.send = function (message) {
                return _this.send(JSON.stringify({ type: name, data: message }));
            };
            this.protocols[name] = protocol;
            if (this.open && protocol.onopen) {
                protocol.onopen();
            }
        }
    }, {
        key: "send",
        value: function send(message) {
            var _this2 = this;

            if (this.socket.readyState === this.socket.OPEN) {
                this.socket.send(message);
            } else {
                if (this.timeoutId) clearTimeout(this.timeoutId);
                this.timeoutId = setTimeout(function () {
                    return _this2.sendBuffered();
                }, 500);
                this.messagesToSend.push(message);
            }
        }
    }, {
        key: "sendBuffered",
        value: function sendBuffered() {
            var _this3 = this;

            if (this.socket.readyState === this.socket.OPEN) {
                this.messagesToSend.forEach(function (message) {
                    return _this3.socket.send(message);
                });
                this.messagesToSend = [];
            } else {
                if (this.timeoutId) clearTimeout(this.timeoutId);
                this.timeoutId = setTimeout(function () {
                    return _this3.sendBuffered();
                }, 500);
            }
        }
    }, {
        key: "connect",
        value: function connect(url, onOpen) {
            var _this4 = this;

            this.socket = new WebSocket(url, 'redux-websocket');
            this.socket.onopen = function () {
                _this4.open = true;
                if (onOpen) {
                    onOpen();
                }
                Object.keys(_this4.protocols).forEach(function (protocolName) {
                    var protocol = _this4.protocols[protocolName];
                    if (protocol.onopen) {
                        protocol.onopen();
                    }
                });
            };
            this.socket.onclose = function () {
                setTimeout(function () {
                    return _this4.connect(url, onOpen);
                }, 1000);
            };
            this.socket.onmessage = function (event) {
                var message = JSON.parse(event.data);
                var protocol = _this4.protocols[message.type];
                if (protocol) {
                    protocol.onmessage(message.data);
                }
            };
        }
    }]);

    return WebSocketClient;
}();

exports.WebSocketClient = WebSocketClient;
exports.websocketMiddleware = function (_ref2) {
    var socket = _ref2.socket;
    var actions = _ref2.actions;
    var id = _ref2.id;
    return function (store) {
        return function (next) {
            if (!actions) {
                actions = {};
            }
            var protocol = {
                onmessage: function onmessage(_ref3) {
                    var action = _ref3.action;

                    next(action);
                }
            };
            socket.registerProtocol("action-" + id, protocol);
            return function (action) {
                var meta = action.meta || actions[action.type] && actions[action.type].meta;
                if (meta && meta.toServer) {
                    protocol.send({ action: action });
                }
                return next(action);
            };
        };
    };
};