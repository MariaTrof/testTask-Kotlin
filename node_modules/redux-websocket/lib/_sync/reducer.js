"use strict";

var redux_decorated_1 = require('redux-decorated');
var constants_1 = require('./constants');
var find_changes_1 = require('./find-changes');
exports.syncReducer = function (_ref, protocol, reducer) {
    var keys = _ref.keys;
    var skipVersion = _ref.skipVersion;

    function maintainVersion(key) {
        return !skipVersion || skipVersion.indexOf(key) === -1;
    }
    return function (actualState, action) {
        var oldState = actualState || {};
        var stateVersions = oldState['versions'] || {};
        switch (action.type) {
            case constants_1.actions.initialSyncedState.type:
                var _action$payload = action.payload;
                var initialState = _action$payload.state;
                var versions = _action$payload.versions;

                return Object.assign({}, oldState, initialState, {
                    versions: Object.assign({}, oldState['versions'], versions)
                });
            case constants_1.actions.updateSyncedState.type:
                var _find_changes_1$apply = find_changes_1.applyChanges(oldState, action.payload, keys);

                var shouldCheckVersions = _find_changes_1$apply.shouldCheckVersions;
                var state = _find_changes_1$apply.state;

                if (shouldCheckVersions) {
                    protocol.maybeCheckVersion();
                }
                return state;
            default:
                var newState = reducer(actualState, action);
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var key = _step.value;

                        if (oldState[key] !== newState[key] && maintainVersion(key)) {
                            var nextVersion = (stateVersions[key] || 0) + 1;
                            newState = redux_decorated_1.updateIn(['versions', key], nextVersion, newState);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return newState;
        }
    };
};