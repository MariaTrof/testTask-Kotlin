"use strict";

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
var index_1 = require('./index');
exports.clientError = index_1.clientError;
function createRpcServer(_ref) {
    var socket = _ref.socket;
    var id = _ref.id;
    var rpcObjects = _ref.rpcObjects;
    var logger = _ref.logger;

    var procedures = {};
    var rpcId = 'rpc' + (id || '');
    var webSocketProtocol = {
        onmessage: function onmessage(_ref2, respond, connectionId) {
            var id = _ref2.id;
            var className = _ref2.className;
            var methodName = _ref2.methodName;
            var args = _ref2.args;

            return __awaiter(this, void 0, void 0, regeneratorRuntime.mark(function _callee() {
                var object, procedure, context, value;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                object = procedures[className];

                                if (object) {
                                    _context.next = 3;
                                    break;
                                }

                                return _context.abrupt('return', respond({ id: id, error: 'no such class' }));

                            case 3:
                                procedure = object[methodName];

                                if (procedure) {
                                    _context.next = 6;
                                    break;
                                }

                                return _context.abrupt('return', respond({ id: id, error: 'no such method' }));

                            case 6:
                                _context.prev = 6;
                                context = { connectionId: connectionId };
                                _context.next = 10;
                                return procedure.apply(context, args);

                            case 10:
                                value = _context.sent;

                                respond({ id: id, value: value });
                                _context.next = 19;
                                break;

                            case 14:
                                _context.prev = 14;
                                _context.t0 = _context['catch'](6);

                                if (logger) {
                                    logger.warn(rpcId + ': ' + className + '.' + methodName + ':', _context.t0, _context.t0 && _context.t0.stack);
                                }
                                _context.t0 = _context.t0 && _context.t0.clientError || 'Unkown Error';
                                respond({ id: id, error: _context.t0 });

                            case 19:
                            case 'end':
                                return _context.stop();
                        }
                    }
                }, _callee, this, [[6, 14]]);
            }));
        }
    };
    socket.registerProtocol(rpcId, webSocketProtocol);
    rpcObjects.forEach(function (rpcObject) {
        var constructor = rpcObject.constructor;
        var className = constructor[index_1.nameSymbol] || constructor.name;
        if (logger) {
            logger.info(rpcId + ': register [' + className + ']');
        }
        procedures[className] = rpcObject;
    });
}
exports.createRpcServer = createRpcServer;