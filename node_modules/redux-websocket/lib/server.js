"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var uuid = require('node-uuid');
var redux_decorated_1 = require('redux-decorated');
var common_1 = require('./common');

var WebSocketServer = function () {
    function WebSocketServer(server) {
        var _this = this;

        _classCallCheck(this, WebSocketServer);

        this.isServer = true;
        this.connections = {};
        this.protocols = {};
        server.on('request', function (request) {
            var connection = request.accept('redux-websocket', request.origin);
            var connectionId = uuid.v1();
            _this.connections[connectionId] = connection;
            Object.keys(_this.protocols).forEach(function (protocolName) {
                var protocol = _this.protocols[protocolName];
                if (protocol.onconnection) {
                    protocol.onconnection(connectionId);
                }
            });
            connection.on('message', function (message) {
                try {
                    if (message.type === 'utf8') {
                        (function () {
                            var data = JSON.parse(message.utf8Data);
                            var protocol = _this.protocols[data.type];
                            if (protocol) {
                                protocol.onmessage(data.data, function (message) {
                                    return connection.send(JSON.stringify({ type: data.type, data: message }));
                                }, connectionId);
                            }
                        })();
                    }
                } catch (e) {
                    connection.send(JSON.stringify({ error: e && e.message }));
                }
            });
            connection.on('close', function () {
                delete _this.connections[connectionId];
                Object.keys(_this.protocols).forEach(function (protocolName) {
                    var protocol = _this.protocols[protocolName];
                    if (protocol.onclose) {
                        protocol.onclose(connectionId);
                    }
                });
            });
        });
    }

    _createClass(WebSocketServer, [{
        key: 'registerProtocol',
        value: function registerProtocol(name, protocol) {
            var _this2 = this;

            protocol.send = function (message, predicate) {
                Object.keys(_this2.connections).forEach(function (connectionId) {
                    if (!predicate || predicate(connectionId)) {
                        _this2.connections[connectionId].send(JSON.stringify({ type: name, data: message }));
                    }
                });
            };
            protocol.sendTo = function (connectionId, message, predicate) {
                if (!predicate || predicate(connectionId)) {
                    _this2.connections[connectionId].send(JSON.stringify({ type: name, data: message }));
                }
            };
            this.protocols[name] = protocol;
        }
    }]);

    return WebSocketServer;
}();

exports.WebSocketServer = WebSocketServer;
exports.websocketMiddleware = function (_ref) {
    var socket = _ref.socket;
    var actions = _ref.actions;
    var _ref$connections = _ref.connections;
    var connections = _ref$connections === undefined ? {} : _ref$connections;
    var id = _ref.id;
    return function (store) {
        return function (next) {
            var protocol = {
                onconnection: function onconnection(connectionId) {
                    connections[connectionId] = true;
                },
                onclose: function onclose(connectionId) {
                    delete connections[connectionId];
                },
                onmessage: function onmessage(_ref2, _, connectionId) {
                    var action = _ref2.action;

                    if (actions[action.type]) {
                        var meta = actions[action.type].meta;

                        if (meta && meta.toServer) {
                            var toServer = meta.toServer;

                            if (typeof toServer !== 'function' || toServer(action, connectionId)) {
                                next(action);
                            }
                        }
                    }
                }
            };
            socket.registerProtocol('action-' + id, protocol);
            return function (action) {
                var meta = action.meta || actions[action.type] && actions[action.type].meta;
                if (meta && meta.toClient) {
                    (function () {
                        var toClient = meta.toClient;
                        var toClientMode = meta.toClientMode;

                        if (toClientMode === common_1.ClientMode.sameStore) {
                            Object.keys(connections).forEach(function (connectionId) {
                                protocol.sendTo(connectionId, { action: redux_decorated_1.updateIn(['meta', 'fromServer'], true, action) }, typeof toClient === 'function' && toClient.bind(null, action));
                            });
                        } else if (toClientMode === common_1.ClientMode.broadcast) {
                            protocol.send({ action: redux_decorated_1.updateIn(['meta', 'fromServer'], true, action) }, typeof toClient === 'function' && toClient.bind(null, action));
                        } else {
                            throw Error('toClientMode must be set when toClient is set');
                        }
                    })();
                }
                return next(action);
            };
        };
    };
};